{"ast":null,"code":"import { createSelector, createEntityAdapter } from \"@reduxjs/toolkit\";\nimport { add, sub } from \"date-fns\";\nimport { apiSlice } from \"./apiSlice\";\n\n// ordenamos los posts por fecha\nconst postsAdapter = createEntityAdapter({\n  sortComparer: (a, b) => b.id - a.id\n});\n\n// Creamos el initalState con el postsAdapter\nconst initialState = postsAdapter.getInitialState();\n\n// Aqui vamos a llamar a la api con los diferente metodos HTTP\n\nexport const extendedApiSlice = apiSlice.injectEndpoints({\n  endpoints: builder => ({\n    getPosts: builder.query({\n      query: () => '/blogs/',\n      // Usamos el transformResponse para agregar la fecha, reacciones y tambien para noramlizar los datos con el postsAdapter.setAll\n      transformResponse: responseData => {\n        const loadedPosts = responseData.map(post => {\n          return post;\n        });\n        return postsAdapter.setAll(initialState, loadedPosts);\n      },\n      // Aqui estamos pondiendo el tag para refrescar el cache, para cuando hagamos una mutacion se puedan mostrar los nuevos datos, \n      // basicamente cuando llamamos a este tag las publicaciones se van a volver a refrescar\n      providesTags: (result, error, arg) => [{\n        type: 'Post',\n        id: \"LIST\"\n      },\n      // aqui luego estamos poniendo un objecto para cada post individual pasando el id del post, y estamos haciendo esto mapieando el result\n      // y lo estamos esparciendo en diferentes post ids y terinaos con esto de type post y id por cada post,\n      // entonces si invalidamos alguno de estos post ids tambien se va a refrescar todos los posts.\n      ...result.ids.map(id => ({\n        type: 'Post',\n        id\n      }))]\n    }),\n    addNewPost: builder.mutation({\n      query: initialPost => ({\n        url: '/blogs/',\n        method: 'POST',\n        body: {\n          ...initialPost\n        }\n      }),\n      invalidatesTags: [{\n        type: 'Post',\n        id: \"LIST\"\n      }]\n    }),\n    updatePost: builder.mutation({\n      query: initialPost => ({\n        url: `/blogs/${initialPost.id}/`,\n        method: 'PUT',\n        body: {\n          ...initialPost\n        }\n      }),\n      invalidatesTags: (result, error, arg) => [{\n        type: 'Post',\n        id: arg.id\n      }]\n    }),\n    deletePost: builder.mutation({\n      query: _ref => {\n        let {\n          id\n        } = _ref;\n        return {\n          url: `/blogs/${id}/`,\n          method: 'DELETE',\n          body: {\n            id\n          }\n        };\n      },\n      invalidatesTags: (result, error, arg) => [{\n        type: 'Post',\n        id: arg.id\n      }]\n    })\n  })\n});\nexport const {\n  useUpdatePostMutation,\n  useDeletePostMutation,\n  useAddNewPostMutation,\n  useGetPostsQuery\n} = extendedApiSlice;\n\n// devuelve el resultado del query, pero es un objecto, nosostros queremos los datos entonces\nexport const selectPostsResult = extendedApiSlice.endpoints.getPosts.select();\n\n// entonces nesitamos usar el createSelector para create este selectPostsData y si recuerdas el createSelector recibe\n// una funcion input y despues tiene una funcion output entonces le pasamos el objecto query selectPostsResult como input\n// y despues el output esta tomando ese resultado y esta agarrando los datos como vemos ahi postsResult.data y ese dats tiene\n// ya los datos normalizados en el estado que tiene los ids y entites\nconst selectPostsData = createSelector(selectPostsResult, postsResult => postsResult.data);\n\n// Aqui agarramos el getSelectors donde crea los selectors y los renombramos con alias \nexport const {\n  selectAll: selectAllPosts,\n  selectById: selectPostById,\n  selectIds: selectPostIds\n  // Despues aqui pasamos el state y usamos el selectPostsData para decirle donde esta el estado y como vemos devuelve el estado normalizado\n  // pero podria ser null sobre todo la primera vez que cargamos la aplicacion y usamos este operador nullish que basicamente si el selectPostsData\n  // es null devuelve el initalState\n} = postsAdapter.getSelectors(state => {\n  var _selectPostsData;\n  return (_selectPostsData = selectPostsData(state)) !== null && _selectPostsData !== void 0 ? _selectPostsData : initialState;\n});","map":{"version":3,"names":["createSelector","createEntityAdapter","add","sub","apiSlice","postsAdapter","sortComparer","a","b","id","initialState","getInitialState","extendedApiSlice","injectEndpoints","endpoints","builder","getPosts","query","transformResponse","responseData","loadedPosts","map","post","setAll","providesTags","result","error","arg","type","ids","addNewPost","mutation","initialPost","url","method","body","invalidatesTags","updatePost","deletePost","_ref","useUpdatePostMutation","useDeletePostMutation","useAddNewPostMutation","useGetPostsQuery","selectPostsResult","select","selectPostsData","postsResult","data","selectAll","selectAllPosts","selectById","selectPostById","selectIds","selectPostIds","getSelectors","state","_selectPostsData"],"sources":["/home/agust/GitHub/CRUD-DRF-Redux-Toolkit/frontend/src/features/postsSlice.js"],"sourcesContent":["import { createSelector, createEntityAdapter } from \"@reduxjs/toolkit\";\nimport { add, sub } from \"date-fns\";\nimport { apiSlice } from \"./apiSlice\";\n\n// ordenamos los posts por fecha\nconst postsAdapter = createEntityAdapter({\n    sortComparer: ((a, b) => b.id - a.id)\n});\n\n// Creamos el initalState con el postsAdapter\nconst initialState = postsAdapter.getInitialState();\n\n// Aqui vamos a llamar a la api con los diferente metodos HTTP\n\nexport const extendedApiSlice = apiSlice.injectEndpoints({\n    endpoints: builder => ({\n        getPosts: builder.query({\n            query: () => '/blogs/',\n            // Usamos el transformResponse para agregar la fecha, reacciones y tambien para noramlizar los datos con el postsAdapter.setAll\n            transformResponse: responseData => {\n                const loadedPosts = responseData.map( post => {\n                    return post\n                })\n                return postsAdapter.setAll(initialState, loadedPosts)\n            },\n            // Aqui estamos pondiendo el tag para refrescar el cache, para cuando hagamos una mutacion se puedan mostrar los nuevos datos, \n            // basicamente cuando llamamos a este tag las publicaciones se van a volver a refrescar\n            providesTags: (result, error, arg) => [\n                { type: 'Post', id: \"LIST\" },\n                // aqui luego estamos poniendo un objecto para cada post individual pasando el id del post, y estamos haciendo esto mapieando el result\n                // y lo estamos esparciendo en diferentes post ids y terinaos con esto de type post y id por cada post,\n                // entonces si invalidamos alguno de estos post ids tambien se va a refrescar todos los posts.\n                ...result.ids.map(id => ({ type: 'Post', id }))\n            ]\n        }),\n        addNewPost: builder.mutation({\n            query: initialPost => ({\n                url: '/blogs/',\n                method: 'POST',\n                body: { ...initialPost }\n            }),\n            invalidatesTags: [\n                { type: 'Post', id: \"LIST\" }\n            ]\n        }),\n        updatePost: builder.mutation({\n            query: initialPost => ({\n                url: `/blogs/${initialPost.id}/`,\n                method: 'PUT',\n                body: { ...initialPost }\n            }), \n            invalidatesTags: (result, error, arg) => [\n                { type: 'Post',id: arg.id }\n            ]\n        }), \n        deletePost: builder.mutation({\n            query: ({ id }) => ({\n                url: `/blogs/${id}/`,\n                method: 'DELETE',\n                body: { id }\n            }), \n            invalidatesTags: (result, error, arg) => [\n                { type: 'Post', id: arg.id }\n            ]\n        })\n    })\n});\n\nexport const { \n    useUpdatePostMutation,\n    useDeletePostMutation,\n    useAddNewPostMutation,\n    useGetPostsQuery, \n} = extendedApiSlice;\n\n// devuelve el resultado del query, pero es un objecto, nosostros queremos los datos entonces\nexport const selectPostsResult = extendedApiSlice.endpoints.getPosts.select();\n\n// entonces nesitamos usar el createSelector para create este selectPostsData y si recuerdas el createSelector recibe\n// una funcion input y despues tiene una funcion output entonces le pasamos el objecto query selectPostsResult como input\n// y despues el output esta tomando ese resultado y esta agarrando los datos como vemos ahi postsResult.data y ese dats tiene\n// ya los datos normalizados en el estado que tiene los ids y entites\nconst selectPostsData = createSelector(\n    selectPostsResult,\n    postsResult => postsResult.data\n)\n\n// Aqui agarramos el getSelectors donde crea los selectors y los renombramos con alias \nexport const { \n    selectAll: selectAllPosts,\n    selectById: selectPostById, \n    selectIds: selectPostIds \n    // Despues aqui pasamos el state y usamos el selectPostsData para decirle donde esta el estado y como vemos devuelve el estado normalizado\n    // pero podria ser null sobre todo la primera vez que cargamos la aplicacion y usamos este operador nullish que basicamente si el selectPostsData\n    // es null devuelve el initalState\n} = postsAdapter.getSelectors(state => selectPostsData(state) ?? initialState) \n\n\n\n\n\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}